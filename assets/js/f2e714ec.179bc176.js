"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[3705],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,k=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(k,o(o({ref:t},c),{},{components:n})):a.createElement(k,o({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},92511:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),i=n(44996);const o={id:"04-creating-tasks",title:"Creating tasks"},s=void 0,l={unversionedId:"tutorials/todo-app/04-creating-tasks",id:"tutorials/todo-app/04-creating-tasks",title:"Creating tasks",description:"To enable the creation of new tasks, we will need two things:",source:"@site/docs/tutorials/todo-app/04-creating-tasks.md",sourceDirName:"tutorials/todo-app",slug:"/tutorials/todo-app/04-creating-tasks",permalink:"/docs/tutorials/todo-app/04-creating-tasks",draft:!1,editUrl:"https://github.com/wasp-lang/wasp/edit/main/web/docs/tutorials/todo-app/04-creating-tasks.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"04-creating-tasks",title:"Creating tasks"},sidebar:"docs",previous:{title:"Listing tasks",permalink:"/docs/tutorials/todo-app/03-listing-tasks"},next:{title:"Updating tasks",permalink:"/docs/tutorials/todo-app/05-updating-tasks"}},p={},c=[{value:"Action",id:"action",level:2},{value:"Wasp declaration",id:"wasp-declaration",level:3},{value:"JS implementation",id:"js-implementation",level:3},{value:"React form",id:"react-form",level:2},{value:"Side note: Automatic invalidation/updating of queries",id:"side-note-automatic-invalidationupdating-of-queries",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"To enable the creation of new tasks, we will need two things:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A Wasp action that creates a new task."),(0,r.kt)("li",{parentName:"ol"},"A React form which calls that action with the new task's data.")),(0,r.kt)("h2",{id:"action"},"Action"),(0,r.kt)("p",null,"Creating an action is very similar to creating a query."),(0,r.kt)("h3",{id:"wasp-declaration"},"Wasp declaration"),(0,r.kt)("p",null,"First we declare the action in Wasp:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction createTask {\n  fn: import { createTask } from "@server/actions",\n  entities: [Task]\n}\n')),(0,r.kt)("h3",{id:"js-implementation"},"JS implementation"),(0,r.kt)("p",null,"Next, we define a JS function for that action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/actions.js"',title:'"src/server/actions.js"'},"export const createTask = async (args, context) => {\n  return context.entities.Task.create({\n    data: { description: args.description }\n  })\n}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We put the JS function in a new file ",(0,r.kt)("inlineCode",{parentName:"p"},"src/server/actions.js"),", but we could have put it anywhere we wanted! There are no limitations here, as long as the import statement in the Wasp file is correct and the source file is inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"src/server")," folder.")),(0,r.kt)("h2",{id:"react-form"},"React form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'{3,10,37-59} title="src/client/MainPage.jsx"',"{3,10,37-59}":!0,title:'"src/client/MainPage.jsx"'},"import { useQuery } from '@wasp/queries'\nimport getTasks from '@wasp/queries/getTasks'\nimport createTask from '@wasp/actions/createTask'\n\nconst MainPage = () => {\n  const { data: tasks, isFetching, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      <NewTaskForm />\n\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isFetching && 'Fetching...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n\nconst Task = (props) => {\n  return (\n    <div>\n      <input\n        type='checkbox' id={props.task.id}\n        checked={props.task.isDone}\n      />\n      {props.task.description}\n    </div>\n  )\n}\n\nconst TasksList = (props) => {\n  if (!props.tasks?.length) return 'No tasks'\n  return props.tasks.map((task, idx) => <Task task={task} key={idx} />)\n}\n\nconst NewTaskForm = (props) => {\n  const handleSubmit = async (event) => {\n    event.preventDefault()\n    try {\n      const description = event.target.description.value\n      event.target.reset()\n      await createTask({ description })\n    } catch (err) {\n      window.alert('Error: ' + err.message)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name='description'\n        type='text'\n        defaultValue=''\n      />\n      <input type='submit' value='Create task' />\n    </form>\n  )\n}\n\nexport default MainPage\n")),(0,r.kt)("p",null,"Here we call our action directly (no hooks) because we don't need any reactivity. The rest is just regular React code."),(0,r.kt)("p",null,"That's it!\nTry creating a \"Build a Todo App in Wasp\" task and see it appear in the list below.\nThe task is created on the server and also saved in the database. Try refreshing the page or opening it in another browser - you'll see the tasks are still here!"),(0,r.kt)("img",{alt:"Todo App - creating new task",src:(0,i.Z)("img/todo-app-new-task.png"),style:{border:"1px solid black"}}),(0,r.kt)("h2",{id:"side-note-automatic-invalidationupdating-of-queries"},"Side note: Automatic invalidation/updating of queries"),(0,r.kt)("p",null,"You will notice that when you create a new task, the list of tasks is automatically updated with that new task, although we have written no code to take care of that! Normally, you would have to do this explicitly, e.g. with ",(0,r.kt)("inlineCode",{parentName:"p"},"react-query")," you would invalidate the ",(0,r.kt)("inlineCode",{parentName:"p"},"getTasks")," query via its key, or would call its ",(0,r.kt)("inlineCode",{parentName:"p"},"refetch()")," method."),(0,r.kt)("p",null,"The reason why the ",(0,r.kt)("inlineCode",{parentName:"p"},"getTasks")," query automatically updates when the ",(0,r.kt)("inlineCode",{parentName:"p"},"createTask")," action is executed is because Wasp is aware that both of them are working with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Task")," entity, and therefore assumes that action that operates on ",(0,r.kt)("inlineCode",{parentName:"p"},"Task")," (in this case ",(0,r.kt)("inlineCode",{parentName:"p"},"createTask"),") might have changed the result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"getTasks")," query. Therefore, in the background, Wasp nudges the ",(0,r.kt)("inlineCode",{parentName:"p"},"getTasks")," query to update. This means that ",(0,r.kt)("strong",{parentName:"p"},"out of the box, Wasp will make sure that all your queries that deal with entities are always in sync with any changes that the actions might have done"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"While this kind of approach to automatic invalidation of queries is very convenient, it is in some situations wasteful and could become a performance bottleneck as the app grows. In that case, you will be able to override this default behaviour and instead provide more detailed (and performant) instructions on how the specific action should affect queries. This is not yet implemented, but is something we plan to do and you can track the progress ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/wasp-lang/wasp/issues/63"},"here")," (or even contribute!).")))}d.isMDXComponent=!0}}]);